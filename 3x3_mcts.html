<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>3x3 井字棋（MCTS AI）</title>
  <style>
    body { font-family: Arial, sans-serif; display:flex; flex-direction:column; align-items:center; padding:20px }
    #board { display:grid; grid-template-columns:repeat(3, 80px); grid-gap:8px; }
    .cell { width:80px; height:80px; background:#f0f0f0; display:flex; align-items:center; justify-content:center; font-size:40px; cursor:pointer }
    .cell.disabled { pointer-events: none; opacity:0.6 }
    #status { margin-top:12px }
    .controls { margin-top:8px }
    button { margin-left:8px }
  </style>
</head>
<body>
  <h2>3x3 井字棋（MCTS AI）</h2>
  <div id="board"></div>
  <div id="status">加载模型中……</div>
  <div class="controls">
    <label>Playouts: <input id="nplay" type="number" value="200" min="1" style="width:80px"></label>
    <button id="resetBtn">重置</button>
  </div>

  <script>
// ========== 基本棋盘逻辑（与原文件相同，仅删除 ONNX 相关） ==========
const width = 3, height = 3, n_in_row = 3;
let states = {};          // move -> player
let availables = [...Array(width*height).keys()];
let current_player = 1;   // 1 人，2 AI
let last_move = -1;

const boardEl   = document.getElementById('board');
const statusEl  = document.getElementById('status');
const resetBtn  = document.getElementById('resetBtn');
const nplayEl   = document.getElementById('nplay');

function createBoard(){
  boardEl.innerHTML = '';
  for(let i=0;i<width*height;i++){
    const c = document.createElement('div');
    c.className = 'cell';
    c.id = 'cell-'+i;
    c.addEventListener('click', ()=>onCellClick(i));
    boardEl.appendChild(c);
  }
}

function onCellClick(i){
  if(!(i in states) && current_player===1){
    doMove(i, 1);
    if(checkEnd()) return;
    current_player = 2;
    statusEl.textContent = 'AI 思考中...';
    setTimeout(()=>runMCThenAIMove(), 50); // 让 UI 先刷新
  }
}

function doMove(move, player){
  states[move] = player;
  availables = availables.filter(x=>x!==move);
  last_move = move;
  const el = document.getElementById('cell-'+move);
  el.textContent = (player===1)?'X':'O';
  el.classList.add('disabled');
}

function reset(){
  states = {};
  availables = [...Array(width*height).keys()];
  current_player = 1;
  last_move = -1;
  statusEl.textContent = '你的回合 (X)';
  createBoard();
}

function checkEnd(){
  const lines = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];
  for(const line of lines){
    const a = states[line[0]]; if(!a) continue;
    if(states[line[1]]===a && states[line[2]]===a){
      statusEl.textContent = (a===1)?'你赢了！':'AI 赢了！';
      disableAll(); return true;
    }
  }
  if(availables.length===0){ statusEl.textContent = '平局'; return true; }
  return false;
}

function disableAll(){
  for(let i=0;i<width*height;i++){
    document.getElementById('cell-'+i).classList.add('disabled');
  }
}

// ========== 蒙特卡洛模拟 ==========
// 快速判断终局，返回 {end, winner}  winner: 1/2/-1(平)
function gameEnd(boardStates){
  const lines = [
    [0,1,2],[3,4,5],[6,7,8],
    [0,3,6],[1,4,7],[2,5,8],
    [0,4,8],[2,4,6]
  ];
  for(const L of lines){
    const a = boardStates[L[0]]; if(!a) continue;
    if(boardStates[L[1]]===a && boardStates[L[2]]===a) return {end:true, winner:a};
  }
  if(Object.keys(boardStates).length === 9) return {end:true, winner:-1};
  return {end:false, winner:-1};
}

// 对单个候选动作做 numRollouts 次随机 rollout
function simulateOneAction(move, numRollouts){
  let win = 0;
  for(let k=0;k<numRollouts;k++){
    // 深拷贝当前局面
    const board = JSON.parse(JSON.stringify(states));
    board[move] = 2;               // AI 先下这一步
    let player = 1;                // 接下来是人
    let acts = availables.filter(x=>x!==move);
    while(true){
      const ge = gameEnd(board);
      if(ge.end){
        if(ge.winner===2) win += 1;
        else if(ge.winner===-1) win += 0.5;
        break;
      }
      // 随机走子
      const m = acts[Math.floor(Math.random()*acts.length)];
      board[m] = player;
      acts = acts.filter(x=>x!==m);
      player = 3 - player; // 1<->2
    }
  }
  return win / numRollouts;
}

// AI 选点
function runMCThenAIMove(){
  const numRollouts = Math.max(50, parseInt(nplayEl.value)||200);
  let bestMove  = null;
  let bestScore = -1;
  for(const mv of availables){
    const score = simulateOneAction(mv, numRollouts);
    if(score > bestScore){ bestScore = score; bestMove = mv; }
  }
  if(bestMove===null){ statusEl.textContent='AI 未选中动作'; return; }
  doMove(bestMove, 2);
  if(checkEnd()) return;
  current_player = 1;
  statusEl.textContent = '你的回合 (X)';
}

// ========== 启动 ==========
resetBtn.addEventListener('click', reset);
createBoard();
reset();
statusEl.textContent = '你的回合 (X)';
</script>
</body>
</html>